
enum MESSAGETYPE = ELECTION, COUNTING;

record ToForward = [MESSAGETYPE MESSAGE,int ID, int COUNT];

fun list<ToForward> removeFirstElement(list<ToForward> pending){
	list<ToForward> result = newList(ToForward);
	if (size(pending) == 1){
		return result;
	}
	for i from 1 to size(pending){
		result = result + [:pending[i]:];
	}
	return result;
}

fun ToForward addElement(MESSAGETYPE messageType,int id, int counter){
	ToForward result := [MESSAGE := messageType,ID := id,COUNT := counter];
	return result;
}

const NODEZ = 50;


component Agent(int zone){
	store{
		attrib int id = zone;
		attrib int sizy = 1;
		attrib zone := zone;
		attrib right := (zone+1)%NODEZ;
		attrib left := (zone+NODEZ-1)%NODEZ;
		attrib list<ToForward> pending = newList(ToForward);
		attrib int leader = MAXINT;
		attrib bool done = false;
		
	}
	behaviour{
		IDLE = 
			send[my.right == zone]<ELECTION,my.id,my.sizy>{}.ACTIVELEADER
			
			+
			
			send[my.left == zone](messageType, anId, aCounter){
				pending = pending + [:addElement(messageType, anId, aCounter):];
			}.ACTIVEFOLLOWER;
			
			ACTIVELEADER = 
				
				send[my.left == zone](messageType, anId, aCounter){
					pending = pending + [:addElement(messageType, anId, aCounter):];
				}.ACTIVELEADER
				
				+
				
				[(size(my.pending) > 0) && pending[0].ID != my.id]send[my.right == zone]<pending[0].MESSAGE,pending[0].ID,pending[0].COUNT+1>{
					my.leader = min(my.leader,pending[0].ID);
					my.sizy = my.sizy+1;
					pending = removeFirstElement(pending);
				}.ACTIVELEADER
				
				+
				
				[(size(my.pending) > 0) && pending[0].ID == my.id]doCheck*{}.CHECK;
	
				
			CHECK = 
			
				[pending[0].COUNT == my.sizy && my.leader == my.id]becomeLeader*{
					pending = removeFirstElement(pending);
				}.LEADER
			
				+
				
				[pending[0].COUNT == my.sizy && my.leader != my.id]becomeFollower*{
					
				}.ACTIVEFOLLOWER
				
				+
				
				[pending[0].COUNT != my.sizy]becomeActiveLeader*{}.ACTIVELEADER
				
				+
			
				send[my.left == zone](messageType,anId,aCounter){
					pending = pending + [:addElement(messageType,anId,aCounter):];
				}.CHECK;
	
						
			ACTIVEFOLLOWER = 
				
				send[my.left == zone](messageType, anId, aCounter){
					pending = pending + [:addElement(messageType, anId, aCounter):];
				}.ACTIVEFOLLOWER
				
				+
				
				[(size(my.pending) > 0) && (my.pending[0].MESSAGE == ELECTION)]send<pending[0].MESSAGE,pending[0].ID,pending[0].COUNT>{
					my.leader = min(my.leader,my.pending[0].ID);
					pending = removeFirstElement(pending);
				}.ACTIVEFOLLOWER
				
				+
				
				[(size(my.pending) > 0) && (my.pending[0].MESSAGE == COUNTING)]send[my.right == zone]<pending[0].MESSAGE,pending[0].ID,pending[0].COUNT+1>{
					my.leader = min(my.leader,pending[0].ID);
					pending = removeFirstElement(pending);
				}.FOLLOWER;
				
			LEADER = 
				[!done]send[my.right == zone]<COUNTING,my.id,1>{
					done = true;
				}.LEADER
				
				+
				
				[done]send[my.right == zone](messageType, anId, aCounter){
					my.sizy = aCounter;
				}.LEADER;
			
			FOLLOWER = do*{}.FOLLOWER;
	}
	init{
		IDLE	
	}
}


system AllTheWayInRing {	
	collective {
		for (i ; i < NODEZ ; 1) {
			new Agent(i);
		}
	}	
	environment {
		store {
			attrib int messages = 0;
			}
		update {
			send{
				messages = global.messages+1;
			}
		}
	}
}

measure leader = #{Agent[LEADER] | true};
measure followerz = #{Agent[FOLLOWER] | true};
measure activefollowerz = #{Agent[ACTIVEFOLLOWER] | true};
measure messages = global.messages;
measure idlez = #{Agent[IDLE] | true};
measure activeleaderz = #{Agent[ACTIVELEADER] | true};
measure activez = #{Agent[ACTIVEFOLLOWER] | true} + #{Agent[ACTIVELEADER] | true};
measure checkz = #{Agent[CHECK] | true};

